// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: regulatormodule/regulatormodule.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package openfmb.regulatormodule;

@kotlin.jvm.JvmName("-initializeregulatorControlATCC")
public inline fun regulatorControlATCC(block: openfmb.regulatormodule.RegulatorControlATCCKt.Dsl.() -> kotlin.Unit): openfmb.regulatormodule.RegulatorControlATCC =
  openfmb.regulatormodule.RegulatorControlATCCKt.Dsl._create(openfmb.regulatormodule.RegulatorControlATCC.newBuilder()).apply { block() }._build()
/**
 * ```
 * LN: Automatic tap changer controller   Name: ATCC
 * ```
 *
 * Protobuf type `regulatormodule.RegulatorControlATCC`
 */
public object RegulatorControlATCCKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: openfmb.regulatormodule.RegulatorControlATCC.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: openfmb.regulatormodule.RegulatorControlATCC.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): openfmb.regulatormodule.RegulatorControlATCC = _builder.build()

    /**
     * ```
     * UML inherited base object
     * ```
     *
     * `.commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];`
     */
    public var logicalNodeForControl: openfmb.commonmodule.LogicalNodeForControl
      @kotlin.jvm.JvmName("getLogicalNodeForControl")
        get() = _builder.logicalNodeForControl
      @kotlin.jvm.JvmName("setLogicalNodeForControl")
        set(value) {
        _builder.logicalNodeForControl = value
      }
    /**
     * ```
     * UML inherited base object
     * ```
     *
     * `.commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];`
     */
    public fun clearLogicalNodeForControl() {
      _builder.clearLogicalNodeForControl()
    }
    /**
     * ```
     * UML inherited base object
     * ```
     *
     * `.commonmodule.LogicalNodeForControl logicalNodeForControl = 1 [(.uml.option_parent_message) = true];`
     * @return Whether the logicalNodeForControl field is set.
     */
    public fun hasLogicalNodeForControl(): kotlin.Boolean {
      return _builder.hasLogicalNodeForControl()
    }

    public val RegulatorControlATCCKt.Dsl.logicalNodeForControlOrNull: openfmb.commonmodule.LogicalNodeForControl?
      get() = _builder.logicalNodeForControlOrNull

    /**
     * ```
     * Forward voltage regulation
     * ```
     *
     * `.regulatormodule.DirectionalATCC DirFwd = 2;`
     */
    public var dirFwd: openfmb.regulatormodule.DirectionalATCC
      @kotlin.jvm.JvmName("getDirFwd")
        get() = _builder.dirFwd
      @kotlin.jvm.JvmName("setDirFwd")
        set(value) {
        _builder.dirFwd = value
      }
    /**
     * ```
     * Forward voltage regulation
     * ```
     *
     * `.regulatormodule.DirectionalATCC DirFwd = 2;`
     */
    public fun clearDirFwd() {
      _builder.clearDirFwd()
    }
    /**
     * ```
     * Forward voltage regulation
     * ```
     *
     * `.regulatormodule.DirectionalATCC DirFwd = 2;`
     * @return Whether the dirFwd field is set.
     */
    public fun hasDirFwd(): kotlin.Boolean {
      return _builder.hasDirFwd()
    }

    public val RegulatorControlATCCKt.Dsl.dirFwdOrNull: openfmb.regulatormodule.DirectionalATCC?
      get() = _builder.dirFwdOrNull

    /**
     * ```
     * The control characteristics for power flow operation
     * ```
     *
     * `.commonmodule.Optional_DirectionModeKind DirMode = 3;`
     */
    public var dirMode: openfmb.commonmodule.Optional_DirectionModeKind
      @kotlin.jvm.JvmName("getDirMode")
        get() = _builder.dirMode
      @kotlin.jvm.JvmName("setDirMode")
        set(value) {
        _builder.dirMode = value
      }
    /**
     * ```
     * The control characteristics for power flow operation
     * ```
     *
     * `.commonmodule.Optional_DirectionModeKind DirMode = 3;`
     */
    public fun clearDirMode() {
      _builder.clearDirMode()
    }
    /**
     * ```
     * The control characteristics for power flow operation
     * ```
     *
     * `.commonmodule.Optional_DirectionModeKind DirMode = 3;`
     * @return Whether the dirMode field is set.
     */
    public fun hasDirMode(): kotlin.Boolean {
      return _builder.hasDirMode()
    }

    public val RegulatorControlATCCKt.Dsl.dirModeOrNull: openfmb.commonmodule.Optional_DirectionModeKind?
      get() = _builder.dirModeOrNull

    /**
     * ```
     * Reverse voltage regulation
     * ```
     *
     * `.regulatormodule.DirectionalATCC DirRev = 4;`
     */
    public var dirRev: openfmb.regulatormodule.DirectionalATCC
      @kotlin.jvm.JvmName("getDirRev")
        get() = _builder.dirRev
      @kotlin.jvm.JvmName("setDirRev")
        set(value) {
        _builder.dirRev = value
      }
    /**
     * ```
     * Reverse voltage regulation
     * ```
     *
     * `.regulatormodule.DirectionalATCC DirRev = 4;`
     */
    public fun clearDirRev() {
      _builder.clearDirRev()
    }
    /**
     * ```
     * Reverse voltage regulation
     * ```
     *
     * `.regulatormodule.DirectionalATCC DirRev = 4;`
     * @return Whether the dirRev field is set.
     */
    public fun hasDirRev(): kotlin.Boolean {
      return _builder.hasDirRev()
    }

    public val RegulatorControlATCCKt.Dsl.dirRevOrNull: openfmb.regulatormodule.DirectionalATCC?
      get() = _builder.dirRevOrNull

    /**
     * ```
     * This is the percentage used to determine the current threshold at which the control recognizes
     * current flow direction. Below the threshold, the current flow is considered to be indeterminate.
     * ```
     *
     * `.commonmodule.PhaseAPC DirThd = 5;`
     */
    public var dirThd: openfmb.commonmodule.PhaseAPC
      @kotlin.jvm.JvmName("getDirThd")
        get() = _builder.dirThd
      @kotlin.jvm.JvmName("setDirThd")
        set(value) {
        _builder.dirThd = value
      }
    /**
     * ```
     * This is the percentage used to determine the current threshold at which the control recognizes
     * current flow direction. Below the threshold, the current flow is considered to be indeterminate.
     * ```
     *
     * `.commonmodule.PhaseAPC DirThd = 5;`
     */
    public fun clearDirThd() {
      _builder.clearDirThd()
    }
    /**
     * ```
     * This is the percentage used to determine the current threshold at which the control recognizes
     * current flow direction. Below the threshold, the current flow is considered to be indeterminate.
     * ```
     *
     * `.commonmodule.PhaseAPC DirThd = 5;`
     * @return Whether the dirThd field is set.
     */
    public fun hasDirThd(): kotlin.Boolean {
      return _builder.hasDirThd()
    }

    public val RegulatorControlATCCKt.Dsl.dirThdOrNull: openfmb.commonmodule.PhaseAPC?
      get() = _builder.dirThdOrNull

    /**
     * ```
     * (controllable) If true, transformers operate in parallel, otherwise they operate independently.
     * ```
     *
     * `.commonmodule.PhaseSPC ParOp = 6;`
     */
    public var parOp: openfmb.commonmodule.PhaseSPC
      @kotlin.jvm.JvmName("getParOp")
        get() = _builder.parOp
      @kotlin.jvm.JvmName("setParOp")
        set(value) {
        _builder.parOp = value
      }
    /**
     * ```
     * (controllable) If true, transformers operate in parallel, otherwise they operate independently.
     * ```
     *
     * `.commonmodule.PhaseSPC ParOp = 6;`
     */
    public fun clearParOp() {
      _builder.clearParOp()
    }
    /**
     * ```
     * (controllable) If true, transformers operate in parallel, otherwise they operate independently.
     * ```
     *
     * `.commonmodule.PhaseSPC ParOp = 6;`
     * @return Whether the parOp field is set.
     */
    public fun hasParOp(): kotlin.Boolean {
      return _builder.hasParOp()
    }

    public val RegulatorControlATCCKt.Dsl.parOpOrNull: openfmb.commonmodule.PhaseSPC?
      get() = _builder.parOpOrNull

    /**
     * ```
     * Ramp rates
     * ```
     *
     * `.commonmodule.RampRate rampRates = 7;`
     */
    public var rampRates: openfmb.commonmodule.RampRate
      @kotlin.jvm.JvmName("getRampRates")
        get() = _builder.rampRates
      @kotlin.jvm.JvmName("setRampRates")
        set(value) {
        _builder.rampRates = value
      }
    /**
     * ```
     * Ramp rates
     * ```
     *
     * `.commonmodule.RampRate rampRates = 7;`
     */
    public fun clearRampRates() {
      _builder.clearRampRates()
    }
    /**
     * ```
     * Ramp rates
     * ```
     *
     * `.commonmodule.RampRate rampRates = 7;`
     * @return Whether the rampRates field is set.
     */
    public fun hasRampRates(): kotlin.Boolean {
      return _builder.hasRampRates()
    }

    public val RegulatorControlATCCKt.Dsl.rampRatesOrNull: openfmb.commonmodule.RampRate?
      get() = _builder.rampRatesOrNull

    /**
     * ```
     * (controllable) Tap position change to the specified value.
     * ```
     *
     * `.commonmodule.Optional_StateKind state = 8;`
     */
    public var state: openfmb.commonmodule.Optional_StateKind
      @kotlin.jvm.JvmName("getState")
        get() = _builder.state
      @kotlin.jvm.JvmName("setState")
        set(value) {
        _builder.state = value
      }
    /**
     * ```
     * (controllable) Tap position change to the specified value.
     * ```
     *
     * `.commonmodule.Optional_StateKind state = 8;`
     */
    public fun clearState() {
      _builder.clearState()
    }
    /**
     * ```
     * (controllable) Tap position change to the specified value.
     * ```
     *
     * `.commonmodule.Optional_StateKind state = 8;`
     * @return Whether the state field is set.
     */
    public fun hasState(): kotlin.Boolean {
      return _builder.hasState()
    }

    public val RegulatorControlATCCKt.Dsl.stateOrNull: openfmb.commonmodule.Optional_StateKind?
      get() = _builder.stateOrNull

    /**
     * ```
     * If true, tap position shall be lowered.
     * ```
     *
     * `.commonmodule.PhaseSPC TapOpL = 9;`
     */
    public var tapOpL: openfmb.commonmodule.PhaseSPC
      @kotlin.jvm.JvmName("getTapOpL")
        get() = _builder.tapOpL
      @kotlin.jvm.JvmName("setTapOpL")
        set(value) {
        _builder.tapOpL = value
      }
    /**
     * ```
     * If true, tap position shall be lowered.
     * ```
     *
     * `.commonmodule.PhaseSPC TapOpL = 9;`
     */
    public fun clearTapOpL() {
      _builder.clearTapOpL()
    }
    /**
     * ```
     * If true, tap position shall be lowered.
     * ```
     *
     * `.commonmodule.PhaseSPC TapOpL = 9;`
     * @return Whether the tapOpL field is set.
     */
    public fun hasTapOpL(): kotlin.Boolean {
      return _builder.hasTapOpL()
    }

    public val RegulatorControlATCCKt.Dsl.tapOpLOrNull: openfmb.commonmodule.PhaseSPC?
      get() = _builder.tapOpLOrNull

    /**
     * ```
     * If true, tap position shall be raised.
     * ```
     *
     * `.commonmodule.PhaseSPC TapOpR = 10;`
     */
    public var tapOpR: openfmb.commonmodule.PhaseSPC
      @kotlin.jvm.JvmName("getTapOpR")
        get() = _builder.tapOpR
      @kotlin.jvm.JvmName("setTapOpR")
        set(value) {
        _builder.tapOpR = value
      }
    /**
     * ```
     * If true, tap position shall be raised.
     * ```
     *
     * `.commonmodule.PhaseSPC TapOpR = 10;`
     */
    public fun clearTapOpR() {
      _builder.clearTapOpR()
    }
    /**
     * ```
     * If true, tap position shall be raised.
     * ```
     *
     * `.commonmodule.PhaseSPC TapOpR = 10;`
     * @return Whether the tapOpR field is set.
     */
    public fun hasTapOpR(): kotlin.Boolean {
      return _builder.hasTapOpR()
    }

    public val RegulatorControlATCCKt.Dsl.tapOpROrNull: openfmb.commonmodule.PhaseSPC?
      get() = _builder.tapOpROrNull

    /**
     * ```
     * High voltage limit for Voltage Limiter
     * ```
     *
     * `.commonmodule.PhaseAPC VolLmtHi = 11;`
     */
    public var volLmtHi: openfmb.commonmodule.PhaseAPC
      @kotlin.jvm.JvmName("getVolLmtHi")
        get() = _builder.volLmtHi
      @kotlin.jvm.JvmName("setVolLmtHi")
        set(value) {
        _builder.volLmtHi = value
      }
    /**
     * ```
     * High voltage limit for Voltage Limiter
     * ```
     *
     * `.commonmodule.PhaseAPC VolLmtHi = 11;`
     */
    public fun clearVolLmtHi() {
      _builder.clearVolLmtHi()
    }
    /**
     * ```
     * High voltage limit for Voltage Limiter
     * ```
     *
     * `.commonmodule.PhaseAPC VolLmtHi = 11;`
     * @return Whether the volLmtHi field is set.
     */
    public fun hasVolLmtHi(): kotlin.Boolean {
      return _builder.hasVolLmtHi()
    }

    public val RegulatorControlATCCKt.Dsl.volLmtHiOrNull: openfmb.commonmodule.PhaseAPC?
      get() = _builder.volLmtHiOrNull

    /**
     * ```
     * Low voltage limit for Voltage Limiter
     * ```
     *
     * `.commonmodule.PhaseAPC VolLmtLo = 12;`
     */
    public var volLmtLo: openfmb.commonmodule.PhaseAPC
      @kotlin.jvm.JvmName("getVolLmtLo")
        get() = _builder.volLmtLo
      @kotlin.jvm.JvmName("setVolLmtLo")
        set(value) {
        _builder.volLmtLo = value
      }
    /**
     * ```
     * Low voltage limit for Voltage Limiter
     * ```
     *
     * `.commonmodule.PhaseAPC VolLmtLo = 12;`
     */
    public fun clearVolLmtLo() {
      _builder.clearVolLmtLo()
    }
    /**
     * ```
     * Low voltage limit for Voltage Limiter
     * ```
     *
     * `.commonmodule.PhaseAPC VolLmtLo = 12;`
     * @return Whether the volLmtLo field is set.
     */
    public fun hasVolLmtLo(): kotlin.Boolean {
      return _builder.hasVolLmtLo()
    }

    public val RegulatorControlATCCKt.Dsl.volLmtLoOrNull: openfmb.commonmodule.PhaseAPC?
      get() = _builder.volLmtLoOrNull

    /**
     * ```
     * Voltage-limiting types
     * ```
     *
     * `.commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;`
     */
    public var volLmtMode: openfmb.commonmodule.Optional_VoltLimitModeKind
      @kotlin.jvm.JvmName("getVolLmtMode")
        get() = _builder.volLmtMode
      @kotlin.jvm.JvmName("setVolLmtMode")
        set(value) {
        _builder.volLmtMode = value
      }
    /**
     * ```
     * Voltage-limiting types
     * ```
     *
     * `.commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;`
     */
    public fun clearVolLmtMode() {
      _builder.clearVolLmtMode()
    }
    /**
     * ```
     * Voltage-limiting types
     * ```
     *
     * `.commonmodule.Optional_VoltLimitModeKind VolLmtMode = 13;`
     * @return Whether the volLmtMode field is set.
     */
    public fun hasVolLmtMode(): kotlin.Boolean {
      return _builder.hasVolLmtMode()
    }

    public val RegulatorControlATCCKt.Dsl.volLmtModeOrNull: openfmb.commonmodule.Optional_VoltLimitModeKind?
      get() = _builder.volLmtModeOrNull
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun openfmb.regulatormodule.RegulatorControlATCC.copy(block: `openfmb.regulatormodule`.RegulatorControlATCCKt.Dsl.() -> kotlin.Unit): openfmb.regulatormodule.RegulatorControlATCC =
  `openfmb.regulatormodule`.RegulatorControlATCCKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.logicalNodeForControlOrNull: openfmb.commonmodule.LogicalNodeForControl?
  get() = if (hasLogicalNodeForControl()) getLogicalNodeForControl() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.dirFwdOrNull: openfmb.regulatormodule.DirectionalATCC?
  get() = if (hasDirFwd()) getDirFwd() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.dirModeOrNull: openfmb.commonmodule.Optional_DirectionModeKind?
  get() = if (hasDirMode()) getDirMode() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.dirRevOrNull: openfmb.regulatormodule.DirectionalATCC?
  get() = if (hasDirRev()) getDirRev() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.dirThdOrNull: openfmb.commonmodule.PhaseAPC?
  get() = if (hasDirThd()) getDirThd() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.parOpOrNull: openfmb.commonmodule.PhaseSPC?
  get() = if (hasParOp()) getParOp() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.rampRatesOrNull: openfmb.commonmodule.RampRate?
  get() = if (hasRampRates()) getRampRates() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.stateOrNull: openfmb.commonmodule.Optional_StateKind?
  get() = if (hasState()) getState() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.tapOpLOrNull: openfmb.commonmodule.PhaseSPC?
  get() = if (hasTapOpL()) getTapOpL() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.tapOpROrNull: openfmb.commonmodule.PhaseSPC?
  get() = if (hasTapOpR()) getTapOpR() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.volLmtHiOrNull: openfmb.commonmodule.PhaseAPC?
  get() = if (hasVolLmtHi()) getVolLmtHi() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.volLmtLoOrNull: openfmb.commonmodule.PhaseAPC?
  get() = if (hasVolLmtLo()) getVolLmtLo() else null

public val openfmb.regulatormodule.RegulatorControlATCCOrBuilder.volLmtModeOrNull: openfmb.commonmodule.Optional_VoltLimitModeKind?
  get() = if (hasVolLmtMode()) getVolLmtMode() else null

