// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: commonmodule/commonmodule.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package openfmb.commonmodule;

@kotlin.jvm.JvmName("-initializevoltageRegulation")
public inline fun voltageRegulation(block: openfmb.commonmodule.VoltageRegulationKt.Dsl.() -> kotlin.Unit): openfmb.commonmodule.VoltageRegulation =
  openfmb.commonmodule.VoltageRegulationKt.Dsl._create(openfmb.commonmodule.VoltageRegulation.newBuilder()).apply { block() }._build()
/**
 * ```
 * Voltage regulation function
 * ```
 *
 * Protobuf type `commonmodule.VoltageRegulation`
 */
public object VoltageRegulationKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: openfmb.commonmodule.VoltageRegulation.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: openfmb.commonmodule.VoltageRegulation.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): openfmb.commonmodule.VoltageRegulation = _builder.build()

    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue overVoltageDroop = 1;`
     */
    public var overVoltageDroop: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getOverVoltageDroop")
        get() = _builder.overVoltageDroop
      @kotlin.jvm.JvmName("setOverVoltageDroop")
        set(value) {
        _builder.overVoltageDroop = value
      }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue overVoltageDroop = 1;`
     */
    public fun clearOverVoltageDroop() {
      _builder.clearOverVoltageDroop()
    }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue overVoltageDroop = 1;`
     * @return Whether the overVoltageDroop field is set.
     */
    public fun hasOverVoltageDroop(): kotlin.Boolean {
      return _builder.hasOverVoltageDroop()
    }

    public val VoltageRegulationKt.Dsl.overVoltageDroopOrNull: com.google.protobuf.FloatValue?
      get() = _builder.overVoltageDroopOrNull

    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue underVoltageDroop = 2;`
     */
    public var underVoltageDroop: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getUnderVoltageDroop")
        get() = _builder.underVoltageDroop
      @kotlin.jvm.JvmName("setUnderVoltageDroop")
        set(value) {
        _builder.underVoltageDroop = value
      }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue underVoltageDroop = 2;`
     */
    public fun clearUnderVoltageDroop() {
      _builder.clearUnderVoltageDroop()
    }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue underVoltageDroop = 2;`
     * @return Whether the underVoltageDroop field is set.
     */
    public fun hasUnderVoltageDroop(): kotlin.Boolean {
      return _builder.hasUnderVoltageDroop()
    }

    public val VoltageRegulationKt.Dsl.underVoltageDroopOrNull: com.google.protobuf.FloatValue?
      get() = _builder.underVoltageDroopOrNull

    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandMinus = 3;`
     */
    public var voltageDeadBandMinus: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getVoltageDeadBandMinus")
        get() = _builder.voltageDeadBandMinus
      @kotlin.jvm.JvmName("setVoltageDeadBandMinus")
        set(value) {
        _builder.voltageDeadBandMinus = value
      }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandMinus = 3;`
     */
    public fun clearVoltageDeadBandMinus() {
      _builder.clearVoltageDeadBandMinus()
    }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandMinus = 3;`
     * @return Whether the voltageDeadBandMinus field is set.
     */
    public fun hasVoltageDeadBandMinus(): kotlin.Boolean {
      return _builder.hasVoltageDeadBandMinus()
    }

    public val VoltageRegulationKt.Dsl.voltageDeadBandMinusOrNull: com.google.protobuf.FloatValue?
      get() = _builder.voltageDeadBandMinusOrNull

    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandPlus = 4;`
     */
    public var voltageDeadBandPlus: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getVoltageDeadBandPlus")
        get() = _builder.voltageDeadBandPlus
      @kotlin.jvm.JvmName("setVoltageDeadBandPlus")
        set(value) {
        _builder.voltageDeadBandPlus = value
      }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandPlus = 4;`
     */
    public fun clearVoltageDeadBandPlus() {
      _builder.clearVoltageDeadBandPlus()
    }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandPlus = 4;`
     * @return Whether the voltageDeadBandPlus field is set.
     */
    public fun hasVoltageDeadBandPlus(): kotlin.Boolean {
      return _builder.hasVoltageDeadBandPlus()
    }

    public val VoltageRegulationKt.Dsl.voltageDeadBandPlusOrNull: com.google.protobuf.FloatValue?
      get() = _builder.voltageDeadBandPlusOrNull

    /**
     * ```
     * uint/0.1V  Other modes of operation, such as peak shaving, smoothing or SOC management may
     * operate if the grid frequency is within the stable band. Upper stable band = frequency set point +
     * band plus Lower stable band = frequency set point – band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageSetPoint = 5;`
     */
    public var voltageSetPoint: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getVoltageSetPoint")
        get() = _builder.voltageSetPoint
      @kotlin.jvm.JvmName("setVoltageSetPoint")
        set(value) {
        _builder.voltageSetPoint = value
      }
    /**
     * ```
     * uint/0.1V  Other modes of operation, such as peak shaving, smoothing or SOC management may
     * operate if the grid frequency is within the stable band. Upper stable band = frequency set point +
     * band plus Lower stable band = frequency set point – band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageSetPoint = 5;`
     */
    public fun clearVoltageSetPoint() {
      _builder.clearVoltageSetPoint()
    }
    /**
     * ```
     * uint/0.1V  Other modes of operation, such as peak shaving, smoothing or SOC management may
     * operate if the grid frequency is within the stable band. Upper stable band = frequency set point +
     * band plus Lower stable band = frequency set point – band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageSetPoint = 5;`
     * @return Whether the voltageSetPoint field is set.
     */
    public fun hasVoltageSetPoint(): kotlin.Boolean {
      return _builder.hasVoltageSetPoint()
    }

    public val VoltageRegulationKt.Dsl.voltageSetPointOrNull: com.google.protobuf.FloatValue?
      get() = _builder.voltageSetPointOrNull
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun openfmb.commonmodule.VoltageRegulation.copy(block: `openfmb.commonmodule`.VoltageRegulationKt.Dsl.() -> kotlin.Unit): openfmb.commonmodule.VoltageRegulation =
  `openfmb.commonmodule`.VoltageRegulationKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val openfmb.commonmodule.VoltageRegulationOrBuilder.overVoltageDroopOrNull: com.google.protobuf.FloatValue?
  get() = if (hasOverVoltageDroop()) getOverVoltageDroop() else null

public val openfmb.commonmodule.VoltageRegulationOrBuilder.underVoltageDroopOrNull: com.google.protobuf.FloatValue?
  get() = if (hasUnderVoltageDroop()) getUnderVoltageDroop() else null

public val openfmb.commonmodule.VoltageRegulationOrBuilder.voltageDeadBandMinusOrNull: com.google.protobuf.FloatValue?
  get() = if (hasVoltageDeadBandMinus()) getVoltageDeadBandMinus() else null

public val openfmb.commonmodule.VoltageRegulationOrBuilder.voltageDeadBandPlusOrNull: com.google.protobuf.FloatValue?
  get() = if (hasVoltageDeadBandPlus()) getVoltageDeadBandPlus() else null

public val openfmb.commonmodule.VoltageRegulationOrBuilder.voltageSetPointOrNull: com.google.protobuf.FloatValue?
  get() = if (hasVoltageSetPoint()) getVoltageSetPoint() else null

