// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: essmodule/essmodule.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package openfmb.essmodule;

@kotlin.jvm.JvmName("-initializesocLimit")
public inline fun socLimit(block: openfmb.essmodule.SocLimitKt.Dsl.() -> kotlin.Unit): openfmb.essmodule.SocLimit =
  openfmb.essmodule.SocLimitKt.Dsl._create(openfmb.essmodule.SocLimit.newBuilder()).apply { block() }._build()
/**
 * ```
 * ESS inverter high level function to shut down ESS if SOC exceeds high or low limits.
 * ```
 *
 * Protobuf type `essmodule.SocLimit`
 */
public object SocLimitKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: openfmb.essmodule.SocLimit.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: openfmb.essmodule.SocLimit.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): openfmb.essmodule.SocLimit = _builder.build()

    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimit = 1;`
     */
    public var socHighLimit: com.google.protobuf.FloatValue
      @JvmName("getSocHighLimit")
      get() = _builder.getSocHighLimit()
      @JvmName("setSocHighLimit")
      set(value) {
        _builder.setSocHighLimit(value)
      }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimit = 1;`
     */
    public fun clearSocHighLimit() {
      _builder.clearSocHighLimit()
    }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimit = 1;`
     * @return Whether the socHighLimit field is set.
     */
    public fun hasSocHighLimit(): kotlin.Boolean {
      return _builder.hasSocHighLimit()
    }

    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimitHysteresis = 2;`
     */
    public var socHighLimitHysteresis: com.google.protobuf.FloatValue
      @JvmName("getSocHighLimitHysteresis")
      get() = _builder.getSocHighLimitHysteresis()
      @JvmName("setSocHighLimitHysteresis")
      set(value) {
        _builder.setSocHighLimitHysteresis(value)
      }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimitHysteresis = 2;`
     */
    public fun clearSocHighLimitHysteresis() {
      _builder.clearSocHighLimitHysteresis()
    }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimitHysteresis = 2;`
     * @return Whether the socHighLimitHysteresis field is set.
     */
    public fun hasSocHighLimitHysteresis(): kotlin.Boolean {
      return _builder.hasSocHighLimitHysteresis()
    }

    /**
     * ```
     * Control value (TRUE or FALSE)
     * ```
     *
     * `.google.protobuf.BoolValue socLimitCtl = 3;`
     */
    public var socLimitCtl: com.google.protobuf.BoolValue
      @JvmName("getSocLimitCtl")
      get() = _builder.getSocLimitCtl()
      @JvmName("setSocLimitCtl")
      set(value) {
        _builder.setSocLimitCtl(value)
      }
    /**
     * ```
     * Control value (TRUE or FALSE)
     * ```
     *
     * `.google.protobuf.BoolValue socLimitCtl = 3;`
     */
    public fun clearSocLimitCtl() {
      _builder.clearSocLimitCtl()
    }
    /**
     * ```
     * Control value (TRUE or FALSE)
     * ```
     *
     * `.google.protobuf.BoolValue socLimitCtl = 3;`
     * @return Whether the socLimitCtl field is set.
     */
    public fun hasSocLimitCtl(): kotlin.Boolean {
      return _builder.hasSocLimitCtl()
    }

    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimit = 4;`
     */
    public var socLowLimit: com.google.protobuf.FloatValue
      @JvmName("getSocLowLimit")
      get() = _builder.getSocLowLimit()
      @JvmName("setSocLowLimit")
      set(value) {
        _builder.setSocLowLimit(value)
      }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimit = 4;`
     */
    public fun clearSocLowLimit() {
      _builder.clearSocLowLimit()
    }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimit = 4;`
     * @return Whether the socLowLimit field is set.
     */
    public fun hasSocLowLimit(): kotlin.Boolean {
      return _builder.hasSocLowLimit()
    }

    /**
     * ```
     * uint/1%  These hysteresis define the release conditions for the block charge or discharge
     * initiated by the SOC limits.For example, assume a SOC low limit of 10% and a SOC low limit
     * hysteresis of 2% and that discharging is blocked because the batteries SOC reached the SOC low
     * limit, discharging will only be allowed again after the battery’s SOC reaches 13%.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimitHysteresis = 5;`
     */
    public var socLowLimitHysteresis: com.google.protobuf.FloatValue
      @JvmName("getSocLowLimitHysteresis")
      get() = _builder.getSocLowLimitHysteresis()
      @JvmName("setSocLowLimitHysteresis")
      set(value) {
        _builder.setSocLowLimitHysteresis(value)
      }
    /**
     * ```
     * uint/1%  These hysteresis define the release conditions for the block charge or discharge
     * initiated by the SOC limits.For example, assume a SOC low limit of 10% and a SOC low limit
     * hysteresis of 2% and that discharging is blocked because the batteries SOC reached the SOC low
     * limit, discharging will only be allowed again after the battery’s SOC reaches 13%.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimitHysteresis = 5;`
     */
    public fun clearSocLowLimitHysteresis() {
      _builder.clearSocLowLimitHysteresis()
    }
    /**
     * ```
     * uint/1%  These hysteresis define the release conditions for the block charge or discharge
     * initiated by the SOC limits.For example, assume a SOC low limit of 10% and a SOC low limit
     * hysteresis of 2% and that discharging is blocked because the batteries SOC reached the SOC low
     * limit, discharging will only be allowed again after the battery’s SOC reaches 13%.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimitHysteresis = 5;`
     * @return Whether the socLowLimitHysteresis field is set.
     */
    public fun hasSocLowLimitHysteresis(): kotlin.Boolean {
      return _builder.hasSocLowLimitHysteresis()
    }
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun openfmb.essmodule.SocLimit.copy(block: openfmb.essmodule.SocLimitKt.Dsl.() -> kotlin.Unit): openfmb.essmodule.SocLimit =
  openfmb.essmodule.SocLimitKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val openfmb.essmodule.SocLimitOrBuilder.socHighLimitOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocHighLimit()) getSocHighLimit() else null

public val openfmb.essmodule.SocLimitOrBuilder.socHighLimitHysteresisOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocHighLimitHysteresis()) getSocHighLimitHysteresis() else null

public val openfmb.essmodule.SocLimitOrBuilder.socLimitCtlOrNull: com.google.protobuf.BoolValue?
  get() = if (hasSocLimitCtl()) getSocLimitCtl() else null

public val openfmb.essmodule.SocLimitOrBuilder.socLowLimitOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocLowLimit()) getSocLowLimit() else null

public val openfmb.essmodule.SocLimitOrBuilder.socLowLimitHysteresisOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocLowLimitHysteresis()) getSocLowLimitHysteresis() else null

