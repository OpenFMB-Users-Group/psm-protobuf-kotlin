// Generated by the protocol buffer compiler. DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: commonmodule/commonmodule.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package openfmb.commonmodule;

@kotlin.jvm.JvmName("-initializesocLimit")
public inline fun socLimit(block: openfmb.commonmodule.SocLimitKt.Dsl.() -> kotlin.Unit): openfmb.commonmodule.SocLimit =
  openfmb.commonmodule.SocLimitKt.Dsl._create(openfmb.commonmodule.SocLimit.newBuilder()).apply { block() }._build()
/**
 * ```
 * ESS inverter high level function to shut down ESS if SOC exceeds high or low limits.
 * ```
 *
 * Protobuf type `commonmodule.SocLimit`
 */
public object SocLimitKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: openfmb.commonmodule.SocLimit.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
      internal fun _create(builder: openfmb.commonmodule.SocLimit.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
  @kotlin.PublishedApi
    internal fun _build(): openfmb.commonmodule.SocLimit = _builder.build()

    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimit = 1;`
     */
    public var socHighLimit: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getSocHighLimit")
        get() = _builder.socHighLimit
      @kotlin.jvm.JvmName("setSocHighLimit")
        set(value) {
        _builder.socHighLimit = value
      }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimit = 1;`
     */
    public fun clearSocHighLimit() {
      _builder.clearSocHighLimit()
    }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimit = 1;`
     * @return Whether the socHighLimit field is set.
     */
    public fun hasSocHighLimit(): kotlin.Boolean {
      return _builder.hasSocHighLimit()
    }

    public val SocLimitKt.Dsl.socHighLimitOrNull: com.google.protobuf.FloatValue?
      get() = _builder.socHighLimitOrNull

    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimitHysteresis = 2;`
     */
    public var socHighLimitHysteresis: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getSocHighLimitHysteresis")
        get() = _builder.socHighLimitHysteresis
      @kotlin.jvm.JvmName("setSocHighLimitHysteresis")
        set(value) {
        _builder.socHighLimitHysteresis = value
      }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimitHysteresis = 2;`
     */
    public fun clearSocHighLimitHysteresis() {
      _builder.clearSocHighLimitHysteresis()
    }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socHighLimitHysteresis = 2;`
     * @return Whether the socHighLimitHysteresis field is set.
     */
    public fun hasSocHighLimitHysteresis(): kotlin.Boolean {
      return _builder.hasSocHighLimitHysteresis()
    }

    public val SocLimitKt.Dsl.socHighLimitHysteresisOrNull: com.google.protobuf.FloatValue?
      get() = _builder.socHighLimitHysteresisOrNull

    /**
     * ```
     * Control value (TRUE or FALSE)
     * ```
     *
     * `.google.protobuf.BoolValue socLimitCtl = 3;`
     */
    public var socLimitCtl: com.google.protobuf.BoolValue
      @kotlin.jvm.JvmName("getSocLimitCtl")
        get() = _builder.socLimitCtl
      @kotlin.jvm.JvmName("setSocLimitCtl")
        set(value) {
        _builder.socLimitCtl = value
      }
    /**
     * ```
     * Control value (TRUE or FALSE)
     * ```
     *
     * `.google.protobuf.BoolValue socLimitCtl = 3;`
     */
    public fun clearSocLimitCtl() {
      _builder.clearSocLimitCtl()
    }
    /**
     * ```
     * Control value (TRUE or FALSE)
     * ```
     *
     * `.google.protobuf.BoolValue socLimitCtl = 3;`
     * @return Whether the socLimitCtl field is set.
     */
    public fun hasSocLimitCtl(): kotlin.Boolean {
      return _builder.hasSocLimitCtl()
    }

    public val SocLimitKt.Dsl.socLimitCtlOrNull: com.google.protobuf.BoolValue?
      get() = _builder.socLimitCtlOrNull

    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimit = 4;`
     */
    public var socLowLimit: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getSocLowLimit")
        get() = _builder.socLowLimit
      @kotlin.jvm.JvmName("setSocLowLimit")
        set(value) {
        _builder.socLowLimit = value
      }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimit = 4;`
     */
    public fun clearSocLowLimit() {
      _builder.clearSocLowLimit()
    }
    /**
     * ```
     * uint/1%  These limits define the operational range of the battery. If a lineup reaches the SOC
     * high limit, the inverter’s output is reduced to 0. Charging is then blocked until the hysteresis is
     * overcome. The same logic applies to the SOC low limit, except that after the ramp down is complete,
     * discharging is blocked until the hysteresis is overcome.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimit = 4;`
     * @return Whether the socLowLimit field is set.
     */
    public fun hasSocLowLimit(): kotlin.Boolean {
      return _builder.hasSocLowLimit()
    }

    public val SocLimitKt.Dsl.socLowLimitOrNull: com.google.protobuf.FloatValue?
      get() = _builder.socLowLimitOrNull

    /**
     * ```
     * uint/1%  These hysteresis define the release conditions for the block charge or discharge
     * initiated by the SOC limits.For example, assume a SOC low limit of 10% and a SOC low limit
     * hysteresis of 2% and that discharging is blocked because the batteries SOC reached the SOC low
     * limit, discharging will only be allowed again after the battery’s SOC reaches 13%.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimitHysteresis = 5;`
     */
    public var socLowLimitHysteresis: com.google.protobuf.FloatValue
      @kotlin.jvm.JvmName("getSocLowLimitHysteresis")
        get() = _builder.socLowLimitHysteresis
      @kotlin.jvm.JvmName("setSocLowLimitHysteresis")
        set(value) {
        _builder.socLowLimitHysteresis = value
      }
    /**
     * ```
     * uint/1%  These hysteresis define the release conditions for the block charge or discharge
     * initiated by the SOC limits.For example, assume a SOC low limit of 10% and a SOC low limit
     * hysteresis of 2% and that discharging is blocked because the batteries SOC reached the SOC low
     * limit, discharging will only be allowed again after the battery’s SOC reaches 13%.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimitHysteresis = 5;`
     */
    public fun clearSocLowLimitHysteresis() {
      _builder.clearSocLowLimitHysteresis()
    }
    /**
     * ```
     * uint/1%  These hysteresis define the release conditions for the block charge or discharge
     * initiated by the SOC limits.For example, assume a SOC low limit of 10% and a SOC low limit
     * hysteresis of 2% and that discharging is blocked because the batteries SOC reached the SOC low
     * limit, discharging will only be allowed again after the battery’s SOC reaches 13%.
     * ```
     *
     * `.google.protobuf.FloatValue socLowLimitHysteresis = 5;`
     * @return Whether the socLowLimitHysteresis field is set.
     */
    public fun hasSocLowLimitHysteresis(): kotlin.Boolean {
      return _builder.hasSocLowLimitHysteresis()
    }

    public val SocLimitKt.Dsl.socLowLimitHysteresisOrNull: com.google.protobuf.FloatValue?
      get() = _builder.socLowLimitHysteresisOrNull
  }
}
@kotlin.jvm.JvmSynthetic
public inline fun openfmb.commonmodule.SocLimit.copy(block: `openfmb.commonmodule`.SocLimitKt.Dsl.() -> kotlin.Unit): openfmb.commonmodule.SocLimit =
  `openfmb.commonmodule`.SocLimitKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val openfmb.commonmodule.SocLimitOrBuilder.socHighLimitOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocHighLimit()) getSocHighLimit() else null

public val openfmb.commonmodule.SocLimitOrBuilder.socHighLimitHysteresisOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocHighLimitHysteresis()) getSocHighLimitHysteresis() else null

public val openfmb.commonmodule.SocLimitOrBuilder.socLimitCtlOrNull: com.google.protobuf.BoolValue?
  get() = if (hasSocLimitCtl()) getSocLimitCtl() else null

public val openfmb.commonmodule.SocLimitOrBuilder.socLowLimitOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocLowLimit()) getSocLowLimit() else null

public val openfmb.commonmodule.SocLimitOrBuilder.socLowLimitHysteresisOrNull: com.google.protobuf.FloatValue?
  get() = if (hasSocLowLimitHysteresis()) getSocLowLimitHysteresis() else null

