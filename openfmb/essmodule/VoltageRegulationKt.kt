// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: essmodule/essmodule.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package openfmb.essmodule;

@kotlin.jvm.JvmName("-initializevoltageRegulation")
public inline fun voltageRegulation(block: openfmb.essmodule.VoltageRegulationKt.Dsl.() -> kotlin.Unit): openfmb.essmodule.VoltageRegulation =
  openfmb.essmodule.VoltageRegulationKt.Dsl._create(openfmb.essmodule.VoltageRegulation.newBuilder()).apply { block() }._build()
/**
 * ```
 * Voltage regulation function
 * ```
 *
 * Protobuf type `essmodule.VoltageRegulation`
 */
public object VoltageRegulationKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: openfmb.essmodule.VoltageRegulation.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: openfmb.essmodule.VoltageRegulation.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): openfmb.essmodule.VoltageRegulation = _builder.build()

    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue overVoltageDroop = 1;`
     */
    public var overVoltageDroop: com.google.protobuf.FloatValue
      @JvmName("getOverVoltageDroop")
      get() = _builder.getOverVoltageDroop()
      @JvmName("setOverVoltageDroop")
      set(value) {
        _builder.setOverVoltageDroop(value)
      }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue overVoltageDroop = 1;`
     */
    public fun clearOverVoltageDroop() {
      _builder.clearOverVoltageDroop()
    }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue overVoltageDroop = 1;`
     * @return Whether the overVoltageDroop field is set.
     */
    public fun hasOverVoltageDroop(): kotlin.Boolean {
      return _builder.hasOverVoltageDroop()
    }

    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue underVoltageDroop = 2;`
     */
    public var underVoltageDroop: com.google.protobuf.FloatValue
      @JvmName("getUnderVoltageDroop")
      get() = _builder.getUnderVoltageDroop()
      @JvmName("setUnderVoltageDroop")
      set(value) {
        _builder.setUnderVoltageDroop(value)
      }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue underVoltageDroop = 2;`
     */
    public fun clearUnderVoltageDroop() {
      _builder.clearUnderVoltageDroop()
    }
    /**
     * ```
     * uint/0.1%  The droops define the reaction of the PCS to under/over voltage events. A droop of 1%
     * means that the PCS will output 100% power if the voltage is 1% of the nominal voltage away from the
     * upper or lower dead band. The minimum droop value possible is 0.8%.
     * ```
     *
     * `.google.protobuf.FloatValue underVoltageDroop = 2;`
     * @return Whether the underVoltageDroop field is set.
     */
    public fun hasUnderVoltageDroop(): kotlin.Boolean {
      return _builder.hasUnderVoltageDroop()
    }

    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandMinus = 3;`
     */
    public var voltageDeadBandMinus: com.google.protobuf.FloatValue
      @JvmName("getVoltageDeadBandMinus")
      get() = _builder.getVoltageDeadBandMinus()
      @JvmName("setVoltageDeadBandMinus")
      set(value) {
        _builder.setVoltageDeadBandMinus(value)
      }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandMinus = 3;`
     */
    public fun clearVoltageDeadBandMinus() {
      _builder.clearVoltageDeadBandMinus()
    }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandMinus = 3;`
     * @return Whether the voltageDeadBandMinus field is set.
     */
    public fun hasVoltageDeadBandMinus(): kotlin.Boolean {
      return _builder.hasVoltageDeadBandMinus()
    }

    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandPlus = 4;`
     */
    public var voltageDeadBandPlus: com.google.protobuf.FloatValue
      @JvmName("getVoltageDeadBandPlus")
      get() = _builder.getVoltageDeadBandPlus()
      @JvmName("setVoltageDeadBandPlus")
      set(value) {
        _builder.setVoltageDeadBandPlus(value)
      }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandPlus = 4;`
     */
    public fun clearVoltageDeadBandPlus() {
      _builder.clearVoltageDeadBandPlus()
    }
    /**
     * ```
     * uint/0.1V  Voltage regulation is performed when the grid voltage goes beyond the dead bands. The
     * dead bands are defined as follows: Upper DB = voltage set point + dead band plus Lower DB = voltage
     * set point – dead band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageDeadBandPlus = 4;`
     * @return Whether the voltageDeadBandPlus field is set.
     */
    public fun hasVoltageDeadBandPlus(): kotlin.Boolean {
      return _builder.hasVoltageDeadBandPlus()
    }

    /**
     * ```
     * uint/0.1V  Other modes of operation, such as peak shaving, smoothing or SOC management may
     * operate if the grid frequency is within the stable band. Upper stable band = frequency set point +
     * band plus Lower stable band = frequency set point – band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageSetPoint = 5;`
     */
    public var voltageSetPoint: com.google.protobuf.FloatValue
      @JvmName("getVoltageSetPoint")
      get() = _builder.getVoltageSetPoint()
      @JvmName("setVoltageSetPoint")
      set(value) {
        _builder.setVoltageSetPoint(value)
      }
    /**
     * ```
     * uint/0.1V  Other modes of operation, such as peak shaving, smoothing or SOC management may
     * operate if the grid frequency is within the stable band. Upper stable band = frequency set point +
     * band plus Lower stable band = frequency set point – band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageSetPoint = 5;`
     */
    public fun clearVoltageSetPoint() {
      _builder.clearVoltageSetPoint()
    }
    /**
     * ```
     * uint/0.1V  Other modes of operation, such as peak shaving, smoothing or SOC management may
     * operate if the grid frequency is within the stable band. Upper stable band = frequency set point +
     * band plus Lower stable band = frequency set point – band minus
     * ```
     *
     * `.google.protobuf.FloatValue voltageSetPoint = 5;`
     * @return Whether the voltageSetPoint field is set.
     */
    public fun hasVoltageSetPoint(): kotlin.Boolean {
      return _builder.hasVoltageSetPoint()
    }
  }
}
@kotlin.jvm.JvmSynthetic
@com.google.errorprone.annotations.CheckReturnValue
public inline fun openfmb.essmodule.VoltageRegulation.copy(block: openfmb.essmodule.VoltageRegulationKt.Dsl.() -> kotlin.Unit): openfmb.essmodule.VoltageRegulation =
  openfmb.essmodule.VoltageRegulationKt.Dsl._create(this.toBuilder()).apply { block() }._build()

public val openfmb.essmodule.VoltageRegulationOrBuilder.overVoltageDroopOrNull: com.google.protobuf.FloatValue?
  get() = if (hasOverVoltageDroop()) getOverVoltageDroop() else null

public val openfmb.essmodule.VoltageRegulationOrBuilder.underVoltageDroopOrNull: com.google.protobuf.FloatValue?
  get() = if (hasUnderVoltageDroop()) getUnderVoltageDroop() else null

public val openfmb.essmodule.VoltageRegulationOrBuilder.voltageDeadBandMinusOrNull: com.google.protobuf.FloatValue?
  get() = if (hasVoltageDeadBandMinus()) getVoltageDeadBandMinus() else null

public val openfmb.essmodule.VoltageRegulationOrBuilder.voltageDeadBandPlusOrNull: com.google.protobuf.FloatValue?
  get() = if (hasVoltageDeadBandPlus()) getVoltageDeadBandPlus() else null

public val openfmb.essmodule.VoltageRegulationOrBuilder.voltageSetPointOrNull: com.google.protobuf.FloatValue?
  get() = if (hasVoltageSetPoint()) getVoltageSetPoint() else null

