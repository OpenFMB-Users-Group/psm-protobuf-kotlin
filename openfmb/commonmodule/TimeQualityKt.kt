// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: commonmodule/commonmodule.proto

// Generated files should ignore deprecation warnings
@file:Suppress("DEPRECATION")
package openfmb.commonmodule;

@kotlin.jvm.JvmName("-initializetimeQuality")
public inline fun timeQuality(block: openfmb.commonmodule.TimeQualityKt.Dsl.() -> kotlin.Unit): openfmb.commonmodule.TimeQuality =
  openfmb.commonmodule.TimeQualityKt.Dsl._create(openfmb.commonmodule.TimeQuality.newBuilder()).apply { block() }._build()
/**
 * ```
 * Information about the quality of the time source of the sending IED.
 * ```
 *
 * Protobuf type `commonmodule.TimeQuality`
 */
public object TimeQualityKt {
  @kotlin.OptIn(com.google.protobuf.kotlin.OnlyForUseByGeneratedProtoCode::class)
  @com.google.protobuf.kotlin.ProtoDslMarker
  public class Dsl private constructor(
    private val _builder: openfmb.commonmodule.TimeQuality.Builder
  ) {
    public companion object {
      @kotlin.jvm.JvmSynthetic
      @kotlin.PublishedApi
      internal fun _create(builder: openfmb.commonmodule.TimeQuality.Builder): Dsl = Dsl(builder)
    }

    @kotlin.jvm.JvmSynthetic
    @kotlin.PublishedApi
    internal fun _build(): openfmb.commonmodule.TimeQuality = _builder.build()

    /**
     * ```
     * If true, the time source of the sending device is unreliable and the value of the time stamp
     * shall be ignored.
     * ```
     *
     * `bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public var clockFailure: kotlin.Boolean
      @JvmName("getClockFailure")
      get() = _builder.getClockFailure()
      @JvmName("setClockFailure")
      set(value) {
        _builder.setClockFailure(value)
      }
    /**
     * ```
     * If true, the time source of the sending device is unreliable and the value of the time stamp
     * shall be ignored.
     * ```
     *
     * `bool clockFailure = 1 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public fun clearClockFailure() {
      _builder.clearClockFailure()
    }

    /**
     * ```
     * If true, the time source of the sending device is not synchronised with the external UTC time.
     * ```
     *
     * `bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public var clockNotSynchronized: kotlin.Boolean
      @JvmName("getClockNotSynchronized")
      get() = _builder.getClockNotSynchronized()
      @JvmName("setClockNotSynchronized")
      set(value) {
        _builder.setClockNotSynchronized(value)
      }
    /**
     * ```
     * If true, the time source of the sending device is not synchronised with the external UTC time.
     * ```
     *
     * `bool clockNotSynchronized = 2 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public fun clearClockNotSynchronized() {
      _builder.clearClockNotSynchronized()
    }

    /**
     * ```
     * If true, the value in 'P_Timestamp.SecondSinceEpoch' contains all leap seconds occurred.
     * Otherwise, it does not take into account the leap seconds that occurred before the initialization of
     * the time source of the device. Instead, the seconds since start of the epoch are calculated from the
     * current date assuming a constant day length of 86 400 seconds. Note: If a UTC time master clock is
     * used and accessible, this value should always be true.
     * ```
     *
     * `bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public var leapSecondsKnown: kotlin.Boolean
      @JvmName("getLeapSecondsKnown")
      get() = _builder.getLeapSecondsKnown()
      @JvmName("setLeapSecondsKnown")
      set(value) {
        _builder.setLeapSecondsKnown(value)
      }
    /**
     * ```
     * If true, the value in 'P_Timestamp.SecondSinceEpoch' contains all leap seconds occurred.
     * Otherwise, it does not take into account the leap seconds that occurred before the initialization of
     * the time source of the device. Instead, the seconds since start of the epoch are calculated from the
     * current date assuming a constant day length of 86 400 seconds. Note: If a UTC time master clock is
     * used and accessible, this value should always be true.
     * ```
     *
     * `bool leapSecondsKnown = 3 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public fun clearLeapSecondsKnown() {
      _builder.clearLeapSecondsKnown()
    }

    /**
     * ```
     * Information about the quality of the time source of the sending IED.
     * ```
     *
     * `.commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public var timeAccuracy: openfmb.commonmodule.TimeAccuracyKind
      @JvmName("getTimeAccuracy")
      get() = _builder.getTimeAccuracy()
      @JvmName("setTimeAccuracy")
      set(value) {
        _builder.setTimeAccuracy(value)
      }
    public var timeAccuracyValue: kotlin.Int
      @JvmName("getTimeAccuracyValue")
      get() = _builder.getTimeAccuracyValue()
      @JvmName("setTimeAccuracyValue")
      set(value) {
        _builder.setTimeAccuracyValue(value)
      }
    /**
     * ```
     * Information about the quality of the time source of the sending IED.
     * ```
     *
     * `.commonmodule.TimeAccuracyKind timeAccuracy = 4 [(.uml.option_required_field) = true, (.uml.option_multiplicity_min) = 1];`
     */
    public fun clearTimeAccuracy() {
      _builder.clearTimeAccuracy()
    }
  }
}
@kotlin.jvm.JvmSynthetic
@com.google.errorprone.annotations.CheckReturnValue
public inline fun openfmb.commonmodule.TimeQuality.copy(block: openfmb.commonmodule.TimeQualityKt.Dsl.() -> kotlin.Unit): openfmb.commonmodule.TimeQuality =
  openfmb.commonmodule.TimeQualityKt.Dsl._create(this.toBuilder()).apply { block() }._build()

